<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>MVP MMORPG UI (Working Content)</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#0f1620; --panel2:#121b26;
      --border:rgba(255,255,255,.09);
      --text:rgba(255,255,255,.86); --muted:rgba(255,255,255,.58);
      --accent:#7aa8ff; --danger:#ff5a6a; --ok:#3ddc97; --warn:#ffcc66;
      --r:14px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; background:var(--bg); color:var(--text); font-family:var(--font); overflow:hidden;}

    .app{height:100vh; display:grid; grid-template-rows: 1fr 290px; gap:12px; padding:12px;}
    .top{display:grid; grid-template-columns: 310px 1fr 330px; gap:12px; min-height:0;}
    .bottom{display:grid; grid-template-columns: 310px 1fr 390px; gap:12px; min-height:0;}

    .panel{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:var(--r);
      overflow:hidden;
      min-height:0;
      display:flex;
      flex-direction:column;
    }
    .hdr{
      display:flex; align-items:center; justify-content:space-between;
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      background:linear-gradient(to bottom, rgba(255,255,255,.06), rgba(255,255,255,0));
    }
    .title{font-weight:900}
    .pill{font-size:12px; padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.12); color:var(--muted); background:rgba(255,255,255,.03);}
    .content{padding:10px 12px; overflow:auto; min-height:0;}
    .muted{color:var(--muted)}
    .hr{height:1px; background:rgba(255,255,255,.10); margin:10px 0;}

    .btn{
      cursor:pointer; user-select:none;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.04);
      color:var(--text);
      padding:8px 10px; border-radius:10px; font-weight:800;
    }
    .btn:hover{background:rgba(255,255,255,.07)}
    .btn.primary{border-color:rgba(122,168,255,.55); background:rgba(122,168,255,.12)}
    .btn.small{padding:6px 8px; font-size:12px; border-radius:9px;}
    .btn:disabled{opacity:.45; cursor:not-allowed}

    /* Room view */
    .scene{position:relative; height:100%; min-height:0; border-radius:14px; overflow:hidden; background:#0a0f15;}
    .sceneBg{
      position:absolute; inset:0;
      background-size:cover;
      filter:saturate(1.05);
      transition: filter 200ms ease;
    }
    .sceneOverlay{
      position:absolute; left:12px; top:12px; right:12px;
      display:flex; justify-content:space-between; gap:12px;
      pointer-events:none;
    }
    .badge{
      pointer-events:none;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(15,22,32,.74);
      backdrop-filter: blur(6px);
      max-width:70%;
    }
    .badge .big{font-weight:1000; font-size:18px}
    .badge .small{font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}

    .roomPanel .roomContent{display:flex; flex-direction:column; gap:10px; height:100%;}
    .statusStrip{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.25);
      border-radius:10px;
      padding:8px 10px;
      font-family:var(--mono);
      font-size:12px;
      color:rgba(255,255,255,.88);
      letter-spacing:.01em;
    }
    .roomHeader{
      border:1px solid rgba(255,255,255,.08);
      background:rgba(0,0,0,.14);
      border-radius:12px;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .roomName{font-size:18px; font-weight:1000;}
    .roomFlavor{font-size:12px; color:var(--muted); line-height:1.35;}
    .roomSel{font-size:11px;}
    .roomFeed{
      flex:1;
      min-height:120px;
      overflow:auto;
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      background:rgba(0,0,0,.16);
      padding:8px 10px;
      font-family:var(--mono);
      font-size:12px;
      line-height:1.25;
      display:flex;
      flex-direction:column;
      gap:3px;
    }
    .rfMsg{display:grid; grid-template-columns:54px 1fr; gap:10px;}
    .rfTime{color:rgba(255,255,255,.45);}
    .rfText{color:rgba(255,255,255,.78);}
    .rf-system .rfText{color:rgba(220,220,220,.70);}
    .rf-combat .rfText{color:rgba(255,146,102,.95);}
    .rf-loot .rfText{color:rgba(110,226,156,.95);}
    .rf-move .rfText{color:rgba(146,205,226,.95);}

    /* Inspector */
    .card{
      background:var(--panel2);
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .h1{font-weight:1000; font-size:18px}
    .hint{font-size:12px; color:var(--muted); line-height:1.4}
    .inspectorDetails summary{cursor:pointer; font-size:12px; color:var(--muted); font-weight:800;}
    .inspectorDetails .kv{margin-top:8px;}
    .tiny{font-size:11px; color:var(--muted);} 
    .kv{display:grid; grid-template-columns: 140px 1fr; gap:6px 10px; font-size:12px; color:rgba(255,255,255,.78)}
    .kv div:nth-child(odd){color:var(--muted)}
    .actions{display:flex; flex-wrap:wrap; gap:8px;}
    .bar{height:8px; border-radius:999px; overflow:hidden; background:rgba(255,255,255,.08)}
    .bar.bad > div{height:100%; background:var(--danger)}
    .selected{outline:2px solid rgba(122,168,255,.55); outline-offset:2px;}

    /* Entities grouped */
    details.group{
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      background:rgba(0,0,0,.14);
      overflow:hidden;
      margin-bottom:8px;
    }
    details.group > summary{
      cursor:pointer;
      padding:10px 10px;
      list-style:none;
      display:flex; align-items:center; justify-content:space-between;
      font-weight:1000;
    }
    details.group > summary::-webkit-details-marker{display:none;}
    .countPill{font-size:12px; padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.12); color:var(--muted);}
    .elist{display:flex; flex-direction:column; gap:6px; padding:10px;}
    .entity{
      display:flex; align-items:center; justify-content:space-between;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.06);
      background:rgba(0,0,0,.10);
      cursor:pointer;
      min-height:36px;
    }
    .entity:hover{border-color:rgba(255,255,255,.14)}
    .entity .name{font-weight:900; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .row{display:flex; align-items:center; gap:8px; min-width:0;}
    .dot{
      width:10px; height:10px; border-radius:50%;
      border:1px solid rgba(255,255,255,.22);
      background:rgba(255,255,255,.10);
      flex:0 0 auto;
    }
    .tag{font-size:11px; padding:2px 6px; border-radius:999px; border:1px solid rgba(255,255,255,.12); color:var(--muted)}

    /* Streams */
    .stream{display:flex; flex-direction:column; min-height:0;}
    .streamBody{
      flex:1; overflow:auto; padding:8px 10px;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:2px;
      font-family: var(--mono);
      font-size:12px;
      line-height:1.25;
    }
    .msg{
      display:grid;
      grid-template-columns: 62px 110px 1fr;
      gap:10px;
      padding:2px 0;
      white-space:normal;
    }
    .msg:hover{ background:rgba(255,255,255,.03); }
    .msg .time{ color:rgba(255,255,255,.50); font-variant-numeric: tabular-nums; white-space:nowrap; }
    .msg .who{ color:rgba(255,255,255,.72); font-weight:700; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .msg .text{ color:rgba(255,255,255,.85); word-break:break-word; }

    .inputRow{display:flex; gap:8px; padding:10px 12px; border-top:1px solid var(--border); background:rgba(0,0,0,.18);}
    .inputRow input{
      flex:1; background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.12);
      border-radius:10px;
      padding:10px; color:var(--text); outline:none;
    }

    /* Map */
    .mapBox{
      padding:10px 12px;
      overflow:hidden;
      flex:1;
      min-height:0;
    }
    .mapSvgWrap{
      height:100%;
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
      background:rgba(0,0,0,.14);
      overflow:hidden;
    }
    .mapSvgWrap svg{ width:100%; height:100%; display:block; }

    /* Compass directions */
    .compassWrap{
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      background:rgba(0,0,0,.14);
      padding:10px;
      margin-bottom:10px;
    }
    .compassTitle{
      font-size:12px;
      color:var(--muted);
      margin-bottom:8px;
      font-weight:800;
      letter-spacing:.02em;
      text-transform:uppercase;
    }
    .compassGrid{
      display:grid;
      grid-template-columns:repeat(3, 1fr);
      grid-template-rows:repeat(3, 42px);
      gap:8px;
      align-items:center;
      justify-items:stretch;
    }
    .compassBtn{
      height:100%;
      width:100%;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.04);
      color:var(--text);
      font-weight:900;
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:.03em;
      cursor:pointer;
    }
    .compassBtn:hover{background:rgba(255,255,255,.08)}
    .compassBtn:disabled{
      cursor:not-allowed;
      color:var(--muted);
      background:rgba(255,255,255,.02);
      border-color:rgba(255,255,255,.08);
      opacity:.7;
    }
    .compassCenter{
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      border:1px solid rgba(122,168,255,.40);
      background:rgba(122,168,255,.10);
      border-radius:10px;
      font-weight:1000;
      font-size:12px;
      letter-spacing:.03em;
      color:rgba(255,255,255,.95);
      text-transform:uppercase;
    }
    .cellNorth{grid-column:2;grid-row:1;}
    .cellWest{grid-column:1;grid-row:2;}
    .cellEast{grid-column:3;grid-row:2;}
    .cellSouth{grid-column:2;grid-row:3;}
    .cellCenter{grid-column:2;grid-row:2;}
  </style>
</head>

<body>
<div class="app">
  <div class="top">
    <div class="panel">
      <div class="hdr"><div class="title">Entities</div><div class="pill">Local</div></div>
      <div class="content" id="entityGroups"></div>
    </div>

    <div class="panel roomPanel">
      <div class="hdr"><div class="title">Room</div><div class="pill" id="youPill">—</div></div>
      <div class="content roomContent">
        <div class="statusStrip" id="statusStrip">HP — | LVL — | XP —</div>
        <div class="roomHeader">
          <div class="roomName" id="roomTitle">—</div>
          <div class="roomFlavor" id="roomFlavor">—</div>
          <div class="roomSel muted">Selected: <span id="selectedName">None</span></div>
        </div>
        <div class="roomFeed" id="roomFeed"></div>
      </div>
    </div>

    <div class="panel">
      <div class="hdr"><div class="title">Inspector</div><div class="pill" id="selKindPill">—</div></div>
      <div class="content" id="inspector"><div class="muted">Select an entity to see details and actions.</div></div>
    </div>
  </div>

  <div class="bottom">
    <div class="panel">
      <div class="hdr"><div class="title">Map</div><div class="pill" id="mapPill">Local</div></div>
      <div class="mapBox">
        <div class="mapSvgWrap" id="minimap"></div>
      </div>
    </div>

    <div class="panel stream">
      <div class="hdr"><div class="title">Personal</div><div class="pill">You</div></div>
      <div class="streamBody" id="logStream"></div>
    </div>

    <div class="panel stream">
      <div class="hdr"><div class="title">Chat</div><div class="pill">Room</div></div>
      <div class="streamBody" id="chatStream"></div>
      <div class="inputRow">
        <input id="chatInput" placeholder="Type chat (Enter)…"/>
        <button class="btn" id="sendChat">Send</button>
      </div>
    </div>
  </div>
</div>

<script>
/* ---------------- Schema / Utils ---------------- */
const Schema = Object.freeze({
  MsgType: { INTENT:"intent", STATE:"state", EVENT:"event" },
  EntityKind: { EXIT:"exit", PLAYER:"player", ENEMY:"enemy", OBJECT:"object", LOOT:"loot" },
  EventKind: { SYSTEM:"system", COMBAT:"combat", CHAT:"chat" },
  Action: {
    CHAT:"chat",
    ENGAGE:"engage", DISENGAGE:"disengage",
    QUEUE_ACTION:"queue_action",
    TRAVEL:"travel", SCOUT_NEXT:"scout_next",
    UNLOCK_DOOR:"unlock_door", OPEN_DOOR:"open_door", CLOSE_DOOR:"close_door",
    OPEN:"open", UNLOCK:"unlock", PICKUP:"pickup"
  }
});

const U = {
  now: () => Date.now(),
  uid: () => (Math.random().toString(16).slice(2) + Math.random().toString(16).slice(2)),
  fmtHp: (hp,max) => `${hp}/${max}`,
  clamp: (n,a,b) => Math.max(a, Math.min(b,n))
};

function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
    .replaceAll('"',"&quot;").replaceAll("'","&#039;");
}
function escapeAttr(s){ return escapeHtml(s).replaceAll("\n"," "); }
function titleCase(s){ return s ? s[0].toUpperCase() + s.slice(1) : s; }

/* ---------------- Room background “themes” ---------------- */
const ThemeBg = Object.freeze({
  road: `radial-gradient(900px 500px at 30% 35%, rgba(255,255,255,.08), transparent 55%),
         radial-gradient(800px 420px at 70% 65%, rgba(122,168,255,.10), transparent 60%),
         linear-gradient(180deg, rgba(255,255,255,.03), transparent 30%),
         url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1200' height='700'%3E%3Crect width='1200' height='700' fill='%230b0f14'/%3E%3Cpath d='M0 520 C 200 420, 420 640, 640 520 C 840 420, 980 640, 1200 500 L 1200 700 L 0 700 Z' fill='%230f1620'/%3E%3Ccircle cx='200' cy='180' r='120' fill='%23121b26'/%3E%3Ccircle cx='980' cy='200' r='150' fill='%23121b26'/%3E%3C/svg%3E")`,
  catacombs: `radial-gradient(900px 500px at 30% 35%, rgba(255,255,255,.05), transparent 55%),
              radial-gradient(800px 420px at 70% 65%, rgba(255,90,106,.08), transparent 60%),
              linear-gradient(180deg, rgba(255,255,255,.02), transparent 30%),
              url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1200' height='700'%3E%3Crect width='1200' height='700' fill='%23090c10'/%3E%3Cpath d='M0 560 C 220 430, 460 650, 680 520 C 860 420, 1000 600, 1200 500 L 1200 700 L 0 700 Z' fill='%230d141d'/%3E%3Cpath d='M120 220 L 240 180 L 300 260 L 180 300 Z' fill='%23121b26' opacity='.85'/%3E%3Cpath d='M900 240 L 1040 200 L 1100 300 L 960 340 Z' fill='%23121b26' opacity='.8'/%3E%3C/svg%3E")`,
  village: `radial-gradient(900px 500px at 30% 35%, rgba(255,255,255,.07), transparent 55%),
            radial-gradient(800px 420px at 70% 65%, rgba(61,220,151,.08), transparent 60%),
            linear-gradient(180deg, rgba(255,255,255,.03), transparent 30%),
            url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1200' height='700'%3E%3Crect width='1200' height='700' fill='%230b0f14'/%3E%3Cpath d='M0 540 C 220 470, 420 610, 640 520 C 860 430, 980 620, 1200 500 L 1200 700 L 0 700 Z' fill='%230f1620'/%3E%3Crect x='160' y='320' width='180' height='120' fill='%23121b26'/%3E%3Cpolygon points='160,320 250,250 340,320' fill='%230f1620'/%3E%3Crect x='820' y='340' width='160' height='110' fill='%23121b26'/%3E%3Cpolygon points='820,340 900,280 980,340' fill='%230f1620'/%3E%3C/svg%3E")`
});

/* ---------------- Room definitions (room “subclasses”) ---------------- */
const RoomDefs = Object.freeze({
  road: {
    defId:"road",
    theme:"road",
    name:"South Country Road",
    flavor:"A dusty path. Wind. Distant footsteps.",
    exits: [
      { dir:"north", toRoomId:"room_2", gate:{ type:"door", doorId:"door_north" } },
      { dir:"east",  toRoomId:"room_3", gate:{ type:"door", doorId:"door_east"  } },
      { dir:"south", toRoomId:"room_4", gate:{ type:"open" } }, // village
      { dir:"west",  toRoomId:"room_1", gate:{ type:"open" } }, // loops to itself
    ],
    doors: {
      door_north: { locked:false, open:false, keyItemDefId:null },
      door_east:  { locked:true,  open:false, keyItemDefId:"rusty_key" }
    },
    staticObjects: [
      { objectType:"chest", id:"chest_road", name:"Old Chest", locked:false }
    ],
    spawn: {
      enemies: [
        {defId:"bandit", name:"Bandit", hp:50, atk:8, def:2, spd:3, maxAlive:1, respawnSec:8},
      ]
    }
  },

  catacombs: {
    defId:"catacombs",
    theme:"catacombs",
    name:"Catacombs Entrance",
    flavor:"Cold air. Dripping water. Your footsteps echo.",
    exits: [
      { dir:"south", toRoomId:"room_1", gate:{ type:"door", doorId:"door_south" } },
      { dir:"west",  toRoomId:"room_1", gate:{ type:"open" } },
    ],
    doors: {
      door_south: { locked:false, open:false, keyItemDefId:null }
    },
    staticObjects: [
      { objectType:"chest", id:"reliquary", name:"Stone Reliquary", locked:true }
    ],
    spawn: {
      enemies: [
        {defId:"skeleton", name:"Skeleton", hp:40, atk:10, def:1, spd:3, maxAlive:2, respawnSec:10},
        {defId:"bandit", name:"Lost Bandit", hp:55, atk:9, def:2, spd:3, maxAlive:1, respawnSec:14}
      ]
    }
  },

  forest: {
    defId:"forest",
    theme:"road",
    name:"Mossy Forest Path",
    flavor:"Birds. Leaves. Something watching you from the trees.",
    exits: [
      { dir:"west", toRoomId:"room_1", gate:{ type:"open" } },
      { dir:"south", toRoomId:"room_4", gate:{ type:"open" } },
    ],
    doors: {},
    staticObjects: [
      { objectType:"chest", id:"stash", name:"Hidden Stash", locked:false }
    ],
    spawn: {
      enemies: [
        {defId:"wolf", name:"Wolf", hp:45, atk:9, def:2, spd:5, maxAlive:2, respawnSec:9},
      ]
    }
  },

  village: {
    defId:"village",
    theme:"village",
    name:"Shire Village",
    flavor:"Warm lanterns. Quiet chatter. Safety… for now.",
    exits: [
      { dir:"north", toRoomId:"room_1", gate:{ type:"open" } },
      { dir:"east",  toRoomId:"room_3", gate:{ type:"open" } }, // forest
    ],
    doors: {},
    staticObjects: [
      { objectType:"chest", id:"crate", name:"Supply Crate", locked:false }
    ],
    spawn: { enemies: [] } // safe zone
  }
});

/* ---------------- Engine ---------------- */
class GameEngine {
  constructor(worldId){
    this.worldId = worldId;
    this.state = this._initWorld();
    this.onSend = (_)=>{};
    setInterval(()=>this._tick(), 200);
  }

  _initWorld(){
    const rooms = {
      room_1: this._newRoom("room_1", RoomDefs.road),
      room_2: this._newRoom("room_2", RoomDefs.catacombs),
      room_3: this._newRoom("room_3", RoomDefs.forest),
      room_4: this._newRoom("room_4", RoomDefs.village),
    };
    for (const r of Object.values(rooms)){
      this._rebuildRoomEntities(r, rooms);
      this._ensureSpawns(r, true);
    }
    return { worldId:this.worldId, rooms, players:{} };
  }

  _newRoom(id, def){
    const doorsState = {};
    for (const [doorId, d] of Object.entries(def.doors || {})){
      doorsState[doorId] = { locked:!!d.locked, open:!!d.open, keyItemDefId: d.keyItemDefId || null };
    }
    return {
      id, defId:def.defId,
      name:def.name, flavor:def.flavor, theme:def.theme,
      doors: doorsState,
      entities:{}, playerIds:[],
      combats:{},
      spawnMeta:{ lastSpawnAt:{} }
    };
  }

  _getDef(defId){
    const def = Object.values(RoomDefs).find(d => d.defId === defId);
    if (!def) throw new Error("Unknown def: "+defId);
    return def;
  }

  _rebuildRoomEntities(room, rooms){
    const def = this._getDef(room.defId);
    room.name = def.name;
    room.flavor = def.flavor;
    room.theme = def.theme ?? room.theme;

    // exits (id stable per dir)
    for (const ex of def.exits){
      const exitId = `exit_${ex.dir}`;
      const destRoom = rooms?.[ex.toRoomId];
      const destName = destRoom ? destRoom.name : ex.toRoomId;

      room.entities[exitId] = {
        id: exitId,
        kind: Schema.EntityKind.EXIT,
        name: ex.dir,
        state: { dir: ex.dir, toRoomId: ex.toRoomId, toRoomName: destName, gate: ex.gate }
      };
    }

    // objects (stable id)
    for (const o of (def.staticObjects || [])){
      const objId = `obj_${o.id}`;
      if (!room.entities[objId]){
        room.entities[objId] = {
          id: objId,
          kind: Schema.EntityKind.OBJECT,
          name: o.name,
          state: { objectType:o.objectType, locked:!!o.locked, opened:false }
        };
      }
    }
  }

  _spawnEnemy(rule){
    return {
      id:"enemy_"+U.uid(),
      kind:Schema.EntityKind.ENEMY,
      name:rule.name,
      state:{
        enemyDefId:rule.defId,
        hp:rule.hp, hpMax:rule.hp,
        stats:{atk:rule.atk, def:rule.def, spd:rule.spd},
        orbit:{ slots:6, assignments:{} }
      }
    };
  }

  _spawnLoot(name, rarity="common"){
    return {
      id:"loot_"+U.uid(),
      kind:Schema.EntityKind.LOOT,
      name,
      state:{ rarity, createdAt: U.now(), expiresAt: U.now()+60000 }
    };
  }

  _ensureSpawns(room, initial){
    const def = this._getDef(room.defId);
    const t = U.now();
    let spawnedAny = false;

    for (const rule of (def.spawn?.enemies || [])){
      const alive = Object.values(room.entities)
        .filter(e => e.kind===Schema.EntityKind.ENEMY && e.state?.enemyDefId===rule.defId).length;
      if (alive >= rule.maxAlive) continue;

      const last = room.spawnMeta.lastSpawnAt[rule.defId] || 0;
      const ms = (rule.respawnSec ?? 10) * 1000;

      if (initial || (t-last>=ms)){
        const e = this._spawnEnemy(rule);
        room.entities[e.id] = e;
        room.spawnMeta.lastSpawnAt[rule.defId] = t;
        spawnedAny = true;
        if (!initial) this._emitEvent(Schema.EventKind.SYSTEM, `A ${rule.name} appears.`, null, { roomId: room.id });
      }
    }
    return spawnedAny;
  }

  _newPlayer(id, name){
    return {
      id, name,
      roomId:"room_1",
      hp:60, hpMax:60,
      lvl:1, xp:0, xpNext:200,
      stats:{atk:10, def:4, spd:4},
      engagedEnemyId:null,
      inventory:[],
      _defending:false
    };
  }

  connect(playerId, name){
    if (this.state.players[playerId]) return;
    this.state.players[playerId] = this._newPlayer(playerId, name || "Adventurer");
    this._enterRoom(playerId, "room_1");
    this._emitEvent(Schema.EventKind.SYSTEM, `${this.state.players[playerId].name} connected.`, null, { actorPlayerId: playerId });
    this._broadcastState();
  }

  _playerEntId(pid){ return "playerEnt_"+pid; }

  _enterRoom(playerId, roomId){
    const p = this.state.players[playerId];
    if (!p) return;

    if (p.roomId && this.state.rooms[p.roomId]){
      const old = this.state.rooms[p.roomId];
      old.playerIds = old.playerIds.filter(x => x!==playerId);
      delete old.entities[this._playerEntId(playerId)];
      p.engagedEnemyId = null;
      p._defending = false;
    }

    const room = this.state.rooms[roomId];
    if (!room) return;

    p.roomId = roomId;
    if (!room.playerIds.includes(playerId)) room.playerIds.push(playerId);

    this._rebuildRoomEntities(room, this.state.rooms);

    room.entities[this._playerEntId(playerId)] = {
      id:this._playerEntId(playerId),
      kind:Schema.EntityKind.PLAYER,
      name:p.name,
      state:{ playerId }
    };

    this._ensureSpawns(room, false);
  }

  _roomOf(pid){
    const p = this.state.players[pid];
    return p ? this.state.rooms[p.roomId] : null;
  }

  handleMessage(msg){
    if (!msg || msg.type !== Schema.MsgType.INTENT) return;
    const { playerId, intent } = msg;
    const p = this.state.players[playerId];
    if (!p) return;

    switch(intent.action){
      case Schema.Action.CHAT:
        this._emitEvent(
          Schema.EventKind.CHAT,
          `${p.name}: ${String(intent.payload?.text||"").slice(0,200)}`,
          null,
          { actorPlayerId: playerId, roomId: p.roomId }
        );
        break;

      case Schema.Action.ENGAGE: this._engage(playerId, intent.targetId); break;
      case Schema.Action.DISENGAGE: this._disengage(playerId); break;
      case Schema.Action.QUEUE_ACTION: this._queueAction(playerId, intent.payload); break;

      case Schema.Action.OPEN: this._openObject(playerId, intent.targetId); break;
      case Schema.Action.UNLOCK: this._unlockObject(playerId, intent.targetId); break;
      case Schema.Action.PICKUP: this._pickup(playerId, intent.targetId); break;

      case Schema.Action.UNLOCK_DOOR: this._unlockDoor(playerId, intent.targetId); break;
      case Schema.Action.OPEN_DOOR: this._openDoor(playerId, intent.targetId); break;
      case Schema.Action.CLOSE_DOOR: this._closeDoor(playerId, intent.targetId); break;

      case Schema.Action.TRAVEL: this._travel(playerId, intent.targetId); break;
      case Schema.Action.SCOUT_NEXT: this._scout(playerId, intent.targetId); break;
    }

    this._broadcastState();
  }

  _emitEvent(kind, text, toPlayerId=null, payload=null, audience="room"){
    const p = { ...(payload || {}) };
    if (!p.roomId && p.actorPlayerId && this.state.players[p.actorPlayerId]){
      p.roomId = this.state.players[p.actorPlayerId].roomId;
    }
    if (!p.roomId && p.targetPlayerId && this.state.players[p.targetPlayerId]){
      p.roomId = this.state.players[p.targetPlayerId].roomId;
    }
    this.onSend({ type:Schema.MsgType.EVENT, kind, text, ts:U.now(), toPlayerId, payload:p, audience });
  }
  _broadcastState(){
    this.onSend({ type:Schema.MsgType.STATE, state: JSON.parse(JSON.stringify(this.state)) });
  }

  _ensureCombat(room, enemyId, initialTurnPid){
    if (!room.combats[enemyId]){
      room.combats[enemyId] = {
        engaged:{},
        actions:{},
        turn:{ phase:"player", turnPid: initialTurnPid, busyUntil:0 }
      };
    } else {
      room.combats[enemyId].turn = room.combats[enemyId].turn || { phase:"player", turnPid: initialTurnPid, busyUntil:0 };
    }
    return room.combats[enemyId];
  }

  _engage(pid, enemyId){
    const room = this._roomOf(pid);
    const p = this.state.players[pid];
    if (!room || !p) return;

    const e = room.entities[enemyId];
    if (!e || e.kind !== Schema.EntityKind.ENEMY) return;

    if (p.engagedEnemyId && p.engagedEnemyId !== enemyId) this._disengage(pid);

    const orbit = e.state.orbit;
    let slot = null;
    for (let i=0;i<orbit.slots;i++){
      if (!orbit.assignments[i]) { slot=i; break; }
    }
    if (slot == null){
      this._emitEvent(Schema.EventKind.SYSTEM, `Tried to engage ${e.name}, but it's crowded.`, null, { actorPlayerId: pid, roomId: room.id, enemyId });
      return;
    }

    orbit.assignments[slot] = pid;
    p.engagedEnemyId = enemyId;

    const combat = this._ensureCombat(room, enemyId, pid);
    combat.engaged[pid] = true;
    combat.turn.turnPid = pid; // MVP: single player “turn owner”

    this._emitEvent(Schema.EventKind.SYSTEM, `You engage the ${e.name}.`, null, { actorPlayerId: pid, roomId: room.id, enemyId }, "room");
  }

  _disengage(pid){
    const room = this._roomOf(pid);
    const p = this.state.players[pid];
    if (!room || !p || !p.engagedEnemyId) return;

    const enemyId = p.engagedEnemyId;
    const e = room.entities[enemyId];
    if (e && e.kind === Schema.EntityKind.ENEMY){
      for (const [slot, who] of Object.entries(e.state.orbit.assignments)){
        if (who === pid) delete e.state.orbit.assignments[slot];
      }
    }

    if (room.combats[enemyId]){
      delete room.combats[enemyId].engaged[pid];
      delete room.combats[enemyId].actions[pid];
    }

    p.engagedEnemyId = null;
    p._defending = false;

    this._emitEvent(Schema.EventKind.SYSTEM, `Disengaged.`, null, { actorPlayerId: pid, roomId: room.id, enemyId });
  }

  _queueAction(pid, action){
    const room = this._roomOf(pid);
    const p = this.state.players[pid];
    if (!room || !p) return;

    if (!p.engagedEnemyId){
      this._emitEvent(Schema.EventKind.SYSTEM, `You're not engaged.`, null, { actorPlayerId: pid, roomId: room.id });
      return;
    }

    const enemyId = p.engagedEnemyId;
    const combat = this._ensureCombat(room, enemyId, pid);

    if (combat.turn.phase !== "player" || combat.turn.turnPid !== pid){
      this._emitEvent(Schema.EventKind.SYSTEM, `Wait…`, null, { actorPlayerId: pid, roomId: room.id, enemyId });
      return;
    }

    combat.actions[pid] = action;
    // Resolve immediately in MVP (no queue batching)
    this._resolveTurnedCombat(room.id, enemyId, pid);
  }

  _resolveTurnedCombat(roomId, enemyId, actorPid){
    const room = this.state.rooms[roomId];
    if (!room) return;

    const combat = room.combats?.[enemyId];
    const enemy  = room.entities?.[enemyId];
    if (!combat || !enemy || enemy.kind !== Schema.EntityKind.ENEMY) return;

    combat.turn = combat.turn || { phase:"player", turnPid: actorPid, busyUntil:0 };
    if (combat.turn.phase !== "player") return;
    if (combat.turn.turnPid !== actorPid) return;

    const engagedIds = Object.keys(combat.engaged || {});
    if (!engagedIds.length) return;

    const p = this.state.players[actorPid];
    if (!p || p.hp <= 0) return;
    if (p.engagedEnemyId !== enemyId) return;

    const a = combat.actions?.[actorPid] || { type:"attack", targetId: enemyId };

    // log your action first (personal)
    const prevEnemyHp = enemy.state.hp;
    const emitEnemyStateNarrative = (beforeHp, afterHp) => {
      const max = enemy.state.hpMax || 1;
      const beforePct = (beforeHp / max) * 100;
      const afterPct = (afterHp / max) * 100;
      const states = [
        { t:75, msg:`${enemy.name} is faltering.` },
        { t:40, msg:`${enemy.name} is badly wounded.` },
        { t:15, msg:`${enemy.name} is near death.` },
      ];
      for (const st of states){
        if (beforePct > st.t && afterPct <= st.t && afterHp > 0){
          this._emitEvent(Schema.EventKind.SYSTEM, st.msg, null, { actorPlayerId: p.id, roomId: room.id, enemyId }, "room");
        }
      }
    };

    if (a.type === "defend"){
      p._defending = true;
      this._emitEvent(Schema.EventKind.SYSTEM, `You brace for impact.`, null, { actorPlayerId: p.id, roomId: room.id, enemyId, targetPlayerId:p.id }, "personal");
    } else {
      let dmg = Math.max(1, p.stats.atk - enemy.state.stats.def);
      if (a.type === "skill") dmg = Math.round(dmg * 1.8);
      enemy.state.hp = Math.max(0, enemy.state.hp - dmg);

      this._emitEvent(Schema.EventKind.COMBAT, `Steel clashes in the dust.`, null, { actorPlayerId: p.id, roomId: room.id, enemyId }, "room");
      this._emitEvent(Schema.EventKind.COMBAT, `You hit ${enemy.name} for ${dmg} (${enemy.state.hp} HP left).`, null, {
        actorPlayerId: p.id, targetPlayerId: p.id, roomId: room.id, enemyId
      }, "personal");

      emitEnemyStateNarrative(prevEnemyHp, enemy.state.hp);
    }

    delete combat.actions[actorPid];

    // enemy dead -> loot -> focus
    if (enemy.state.hp <= 0){
      const loot = this._spawnLoot(`${enemy.name} Coin`, "common");
      room.entities[loot.id] = loot;

      this._emitEvent(Schema.EventKind.SYSTEM, `The ${enemy.name} collapses.`, null, {
        roomId: room.id, enemyId, focusEntityId: loot.id
      }, "room");
      this._emitEvent(Schema.EventKind.SYSTEM, `You defeated ${enemy.name}. Loot dropped: ${loot.name}.`, null, {
        actorPlayerId: actorPid, targetPlayerId: actorPid, roomId: room.id, enemyId, focusEntityId: loot.id
      }, "personal");

      for (const pid of engagedIds){
        const pp = this.state.players[pid];
        if (!pp) continue;
        pp._defending = false;
        pp.engagedEnemyId = null;
        const gainedXp = 25;
        pp.xp = (pp.xp || 0) + gainedXp;
        while (pp.xp >= (pp.xpNext || 200)){
          pp.xp -= pp.xpNext;
          pp.lvl = (pp.lvl || 1) + 1;
          pp.xpNext = Math.round(pp.xpNext * 1.25);
          this._emitEvent(Schema.EventKind.SYSTEM, `${pp.name} reached level ${pp.lvl}.`, null, { actorPlayerId: pp.id, roomId: room.id });
        }
        delete combat.actions[pid];
      }

      delete room.combats[enemyId];
      delete room.entities[enemyId];
      this._broadcastState();
      return;
    }

    // enemy phase: disable buttons on client
    combat.turn.phase = "enemy";
    combat.turn.busyUntil = U.now() + 550;
    this._broadcastState();

    setTimeout(() => {
      const r = this.state.rooms[roomId];
      const c = r?.combats?.[enemyId];
      const en = r?.entities?.[enemyId];
      const pl = this.state.players[actorPid];
      if (!r || !c || !en || !pl) return;

      let edmg = Math.max(1, en.state.stats.atk - pl.stats.def);
      if (pl._defending) edmg = Math.ceil(edmg * 0.6);

      pl.hp = Math.max(0, pl.hp - edmg);

      this._emitEvent(Schema.EventKind.COMBAT, `Steel clashes in the dust.`, null, {
        targetPlayerId: pl.id, roomId: r.id, enemyId
      }, "room");
      this._emitEvent(Schema.EventKind.COMBAT, `${en.name} hits You for ${edmg} (${pl.hp} HP left).`, null, {
        targetPlayerId: pl.id, roomId: r.id, enemyId
      }, "personal");

      pl._defending = false;

      if (pl.hp <= 0){
        this._emitEvent(Schema.EventKind.SYSTEM, `You fall unconscious.`, null, {
          targetPlayerId: pl.id, roomId: r.id, enemyId
        });
        this._disengage(pl.id);
        this._broadcastState();
        return;
      }

      c.turn.phase = "player";
      c.turn.turnPid = actorPid;
      c.turn.busyUntil = 0;
      this._broadcastState();
    }, 550);
  }

  _openObject(pid, objId){
    const room = this._roomOf(pid);
    const p = this.state.players[pid];
    if (!room || !p) return;
    if (p.engagedEnemyId){
      this._emitEvent(Schema.EventKind.SYSTEM, `Can't do that while engaged.`, null, { actorPlayerId: pid, roomId: room.id });
      return;
    }

    const obj = room.entities[objId];
    if (!obj || obj.kind !== Schema.EntityKind.OBJECT) return;

    if (obj.state.objectType === "chest"){
      if (obj.state.locked){
        this._emitEvent(Schema.EventKind.SYSTEM, `The chest is locked.`, null, { actorPlayerId: pid, roomId: room.id, objectId: objId });
        return;
      }
      if (obj.state.opened){
        this._emitEvent(Schema.EventKind.SYSTEM, `The chest is empty.`, null, { actorPlayerId: pid, roomId: room.id, objectId: objId });
        return;
      }

      obj.state.opened = true;

      // drop loot + focus
      const loot = this._spawnLoot("Iron Sword", "common");
      room.entities[loot.id] = loot;

      this._emitEvent(Schema.EventKind.SYSTEM, `Opened chest. Loot: ${loot.name}.`, null, {
        actorPlayerId: pid, roomId: room.id, objectId: objId, focusEntityId: loot.id
      });
    }
  }

  _unlockObject(pid, objId){
    const room = this._roomOf(pid);
    const p = this.state.players[pid];
    if (!room || !p) return;
    if (p.engagedEnemyId){
      this._emitEvent(Schema.EventKind.SYSTEM, `Can't do that while engaged.`, null, { actorPlayerId: pid, roomId: room.id });
      return;
    }

    const obj = room.entities[objId];
    if (!obj || obj.kind !== Schema.EntityKind.OBJECT) return;

    const hasKey = p.inventory.some(it => (it.name||"").toLowerCase().includes("rusty key"));
    if (!obj.state.locked){
      this._emitEvent(Schema.EventKind.SYSTEM, `It's not locked.`, null, { actorPlayerId: pid, roomId: room.id, objectId: objId });
      return;
    }
    if (!hasKey){
      this._emitEvent(Schema.EventKind.SYSTEM, `You need a Rusty Key.`, null, { actorPlayerId: pid, roomId: room.id, objectId: objId });
      return;
    }

    obj.state.locked = false;
    this._emitEvent(Schema.EventKind.SYSTEM, `Unlocked.`, null, { actorPlayerId: pid, roomId: room.id, objectId: objId });
  }

  _pickup(pid, lootId){
    const room = this._roomOf(pid);
    const p = this.state.players[pid];
    if (!room || !p) return;
    if (p.engagedEnemyId){
      this._emitEvent(Schema.EventKind.SYSTEM, `Finish combat first.`, null, { actorPlayerId: pid, roomId: room.id });
      return;
    }

    const loot = room.entities[lootId];
    if (!loot || loot.kind !== Schema.EntityKind.LOOT) return;

    p.inventory.push({ name:loot.name, rarity:loot.state.rarity });

    // small chance to get a key (so doors/chests can be tested)
    if (Math.random() < 0.30) p.inventory.push({ name:"Rusty Key", rarity:"uncommon" });

    delete room.entities[lootId];
    this._emitEvent(Schema.EventKind.SYSTEM, `Picked up ${loot.name}.`, null, { actorPlayerId: pid, roomId: room.id, lootId });
  }

  _exitDoor(room, exitId){
    const ex = room.entities[exitId];
    if (!ex || ex.kind !== Schema.EntityKind.EXIT) return { ex:null, doorId:null, door:null };
    const gate = ex.state.gate || {type:"open"};
    if (gate.type !== "door") return { ex, doorId:null, door:null };
    const doorId = gate.doorId;
    const door = room.doors?.[doorId] || null;
    return { ex, doorId, door };
  }

  _unlockDoor(pid, exitId){
    const room = this._roomOf(pid);
    const p = this.state.players[pid];
    if (!room || !p) return;
    if (p.engagedEnemyId){
      this._emitEvent(Schema.EventKind.SYSTEM, `Can't do that while engaged.`, null, { actorPlayerId: pid, roomId: room.id });
      return;
    }

    const {door, doorId, ex} = this._exitDoor(room, exitId);
    if (!doorId || !door){
      this._emitEvent(Schema.EventKind.SYSTEM, `No door to unlock.`, null, { actorPlayerId: pid, roomId: room.id });
      return;
    }
    if (!door.locked){
      this._emitEvent(Schema.EventKind.SYSTEM, `Door isn't locked.`, null, { actorPlayerId: pid, roomId: room.id });
      return;
    }

    const hasKey = p.inventory.some(it => (it.name||"").toLowerCase().includes("rusty key"));
    if (!hasKey){
      this._emitEvent(Schema.EventKind.SYSTEM, `You need a Rusty Key.`, null, { actorPlayerId: pid, roomId: room.id });
      return;
    }

    door.locked = false;
    this._emitEvent(Schema.EventKind.SYSTEM, `Unlocked the ${titleCase(ex.state.dir)} door.`, null, { actorPlayerId: pid, roomId: room.id });
  }

  _openDoor(pid, exitId){
    const room = this._roomOf(pid);
    const p = this.state.players[pid];
    if (!room || !p) return;
    if (p.engagedEnemyId){
      this._emitEvent(Schema.EventKind.SYSTEM, `Can't do that while engaged.`, null, { actorPlayerId: pid, roomId: room.id });
      return;
    }

    const {door, doorId, ex} = this._exitDoor(room, exitId);
    if (!doorId || !door){
      this._emitEvent(Schema.EventKind.SYSTEM, `No door to open.`, null, { actorPlayerId: pid, roomId: room.id });
      return;
    }
    if (door.locked){
      this._emitEvent(Schema.EventKind.SYSTEM, `Door is locked.`, null, { actorPlayerId: pid, roomId: room.id });
      return;
    }
    if (door.open){
      this._emitEvent(Schema.EventKind.SYSTEM, `Door is already open.`, null, { actorPlayerId: pid, roomId: room.id });
      return;
    }

    door.open = true;
    this._emitEvent(Schema.EventKind.SYSTEM, `Opened the ${titleCase(ex.state.dir)} door.`, null, { actorPlayerId: pid, roomId: room.id });
  }

  _closeDoor(pid, exitId){
    const room = this._roomOf(pid);
    const p = this.state.players[pid];
    if (!room || !p) return;
    if (p.engagedEnemyId){
      this._emitEvent(Schema.EventKind.SYSTEM, `Can't do that while engaged.`, null, { actorPlayerId: pid, roomId: room.id });
      return;
    }

    const {door, doorId, ex} = this._exitDoor(room, exitId);
    if (!doorId || !door){
      this._emitEvent(Schema.EventKind.SYSTEM, `No door to close.`, null, { actorPlayerId: pid, roomId: room.id });
      return;
    }
    if (!door.open){
      this._emitEvent(Schema.EventKind.SYSTEM, `Door is already closed.`, null, { actorPlayerId: pid, roomId: room.id });
      return;
    }

    door.open = false;
    this._emitEvent(Schema.EventKind.SYSTEM, `Closed the ${titleCase(ex.state.dir)} door.`, null, { actorPlayerId: pid, roomId: room.id });
  }

  _travel(pid, exitId){
    const room = this._roomOf(pid);
    const p = this.state.players[pid];
    if (!room || !p) return;
    if (p.engagedEnemyId){
      this._emitEvent(Schema.EventKind.SYSTEM, `Can't move while engaged.`, null, { actorPlayerId: pid, roomId: room.id });
      return;
    }

    const ex = room.entities[exitId];
    if (!ex || ex.kind !== Schema.EntityKind.EXIT) return;

    const gate = ex.state.gate || {type:"open"};
    if (gate.type === "door"){
      const door = room.doors?.[gate.doorId];
      if (!door){ this._emitEvent(Schema.EventKind.SYSTEM, `The way is blocked.`, null, { actorPlayerId: pid, roomId: room.id }); return; }
      if (door.locked){ this._emitEvent(Schema.EventKind.SYSTEM, `Door is locked.`, null, { actorPlayerId: pid, roomId: room.id }); return; }
      if (!door.open){ this._emitEvent(Schema.EventKind.SYSTEM, `Door is closed.`, null, { actorPlayerId: pid, roomId: room.id }); return; }
    }

    const dest = this.state.rooms[ex.state.toRoomId];
    if (!dest){
      this._emitEvent(Schema.EventKind.SYSTEM, `That path leads nowhere (yet).`, null, { actorPlayerId: pid, roomId: room.id });
      return;
    }

    this._emitEvent(Schema.EventKind.SYSTEM, `Moved ${titleCase(ex.state.dir)}.`, null, { actorPlayerId: pid, roomId: room.id });
    this._enterRoom(pid, ex.state.toRoomId);
  }

  _scout(pid, exitId){
    const room = this._roomOf(pid);
    if (!room) return;

    const ex = room.entities[exitId];
    if (!ex || ex.kind !== Schema.EntityKind.EXIT) return;

    const next = this.state.rooms[ex.state.toRoomId];
    if (!next){
      this._emitEvent(Schema.EventKind.SYSTEM, `Only void beyond.`, null, { actorPlayerId: pid, roomId: room.id });
      return;
    }

    const enemies = Object.values(next.entities).filter(e=>e.kind===Schema.EntityKind.ENEMY).map(e=>e.name);
    const objects = Object.values(next.entities).filter(e=>e.kind===Schema.EntityKind.OBJECT).map(e=>e.name);

    const enemyHint = enemies.length===0 ? "no movement"
      : enemies.length===1 ? `movement (${enemies[0]})`
      : `multiple movements (${enemies.slice(0,2).join(", ")}${enemies.length>2?", …":""})`;

    const objHint = objects.some(n=>n.toLowerCase().includes("chest") || n.toLowerCase().includes("crate"))
      ? "You spot something that might be loot."
      : "Nothing of interest stands out.";

    this._emitEvent(Schema.EventKind.SYSTEM, `Scouted ${titleCase(ex.state.dir)}: ${enemyHint}. ${objHint}`, null, { actorPlayerId: pid, roomId: room.id });
  }

  _tick(){
    let dirty = false;

    for (const room of Object.values(this.state.rooms)){
      if (this._ensureSpawns(room, false)) dirty = true;

      const now = U.now();
      for (const ent of Object.values(room.entities)){
        if (ent.kind === Schema.EntityKind.LOOT && ent.state?.expiresAt && now > ent.state.expiresAt){
          delete room.entities[ent.id];
          dirty = true;
        }
      }
    }

    if (dirty) this._broadcastState();
  }
}

/* ---------------- Local transport / Store ---------------- */
class LocalTransport{
  constructor(engine){
    this.engine=engine;
    this.onMessage=(_)=>{};
    engine.onSend=(msg)=>this.onMessage(msg);
  }
  send(msg){ this.engine.handleMessage(msg); }
}
class Store{
  constructor(transport, playerId){
    this.transport=transport; this.playerId=playerId;
    this.state=null; this.events=[]; this.subs=new Set();
    transport.onMessage=(msg)=>this._recv(msg);
  }
  subscribe(fn){ this.subs.add(fn); return ()=>this.subs.delete(fn); }
  _notify(){ for (const fn of this.subs) fn(); }
  dispatch(action, targetId=null, payload=null){
    this.transport.send({ type:Schema.MsgType.INTENT, playerId:this.playerId, intent:{ action, targetId, payload } });
  }
  _recv(msg){
    if (!msg || !msg.type) return;
    if (msg.toPlayerId && msg.toPlayerId!==this.playerId) return;
    if (msg.type===Schema.MsgType.STATE){ this.state=msg.state; this._notify(); return; }
    if (msg.type===Schema.MsgType.EVENT){
      this.events.push(msg);
      if (this.events.length>1200) this.events=this.events.slice(-800);
      this._notify();
    }
  }
}

/* ---------------- Inspector handlers ---------------- */
const Handlers = {
  [Schema.EntityKind.EXIT]: {
    inspect(ent, ctx){
      const title = `${titleCase(ent.state.dir)} (${ent.state.toRoomName || ent.state.toRoomId})`;
      const gate = ent.state.gate || {type:"open"};
      let gateLabel = "Open path";
      if (gate.type==="door"){
        const door = ctx.room.doors?.[gate.doorId];
        gateLabel = door ? `Door (${door.locked ? "locked" : "unlocked"}, ${door.open ? "open" : "closed"})` : "Door (missing)";
      }
      return {
        title,
        kindLabel:"Direction",
        sections:[
          {type:"kv", rows:[["Destination", ent.state.toRoomName || ent.state.toRoomId],["Gate", gateLabel]]},
          {type:"text", text:"If gated: Unlock → Open → Move. You can also scout."}
        ]
      };
    },
    actions(ent, ctx){
      const you = ctx.you;
      const inCombat = !!you?.engagedEnemyId;
      const gate = ent.state.gate || {type:"open"};
      const acts = [];

      if (gate.type==="door"){
        const door = ctx.room.doors?.[gate.doorId] || null;
        const locked = !!door?.locked;
        const open = !!door?.open;

        acts.push({
          label:"Unlock Door",
          style:"",
          enabled: !inCombat && !!door && locked,
          hint: inCombat ? "In combat" : (locked ? "Requires Rusty Key (drops randomly)" : "Not locked"),
          intent:{ action:Schema.Action.UNLOCK_DOOR, targetId: ent.id }
        });
        acts.push({
          label:"Open Door",
          style:"primary",
          enabled: !inCombat && !!door && !locked && !open,
          hint: inCombat ? "In combat" : (locked ? "Locked" : (open ? "Already open" : "")),
          intent:{ action:Schema.Action.OPEN_DOOR, targetId: ent.id }
        });
        acts.push({
          label:"Close Door",
          style:"",
          enabled: !inCombat && !!door && open,
          hint: inCombat ? "In combat" : (open ? "" : "Already closed"),
          intent:{ action:Schema.Action.CLOSE_DOOR, targetId: ent.id }
        });
      }

      let moveEnabled = !inCombat;
      let moveHint = inCombat ? "Can't move while engaged" : "";

      if (gate.type==="door"){
        const door = ctx.room.doors?.[gate.doorId] || null;
        if (!door){ moveEnabled=false; moveHint="Blocked"; }
        else if (door.locked){ moveEnabled=false; moveHint="Locked"; }
        else if (!door.open){ moveEnabled=false; moveHint="Closed"; }
      }

      acts.push({
        label:"Move",
        style:"primary",
        enabled: moveEnabled,
        hint: moveHint,
        intent:{ action:Schema.Action.TRAVEL, targetId: ent.id }
      });

      acts.push({
        label:"Inspect next",
        style:"",
        enabled:true,
        hint:"",
        intent:{ action:Schema.Action.SCOUT_NEXT, targetId: ent.id }
      });

      return acts;
    }
  },

  [Schema.EntityKind.PLAYER]: {
    inspect(ent, ctx){
      const p = ctx.players[ent.state.playerId];
      if (!p) return { title: ent.name, kindLabel:"Player", sections:[{type:"text", text:"Player not found."}] };
      const isYou = p.id === ctx.playerId;

      return {
        title: p.name,
        kindLabel: isYou ? "You" : "Player",
        sections:[
          {type:"kv", rows:[
            ["HP", U.fmtHp(p.hp,p.hpMax)],
            ["Status", p.engagedEnemyId ? "Engaged" : "Idle"],
            ...(isYou ? [["ATK",String(p.stats.atk)],["DEF",String(p.stats.def)],["Inventory",String(p.inventory.length)]] : [])
          ]}
        ]
      };
    },
    actions(){ return []; }
  },

  [Schema.EntityKind.ENEMY]: {
    inspect(ent, ctx){
      const hp = ent.state.hp, hpMax = ent.state.hpMax;
      const combat = ctx.room.combats?.[ent.id] || null;
      const turn = combat?.turn || null;
      const phaseLabel = turn ? (turn.phase === "enemy" ? "Enemy acting…" : "Your turn") : "—";

      return {
        title: ent.name,
        kindLabel:"Enemy",
        sections:[
          { type:"hp", hp, hpMax },
          { type:"kv", rows:[
            ["Engaged", `${Object.keys(ent.state.orbit.assignments||{}).length}/${ent.state.orbit.slots}`],
            ["ATK", String(ent.state.stats.atk)],
            ["DEF", String(ent.state.stats.def)],
            ["Turn", phaseLabel]
          ]},
          { type:"text", text:"All actions here are YOU acting on this enemy." }
        ]
      };
    },
    actions(ent, ctx){
      const you = ctx.you;
      const youEngagedThis = you?.engagedEnemyId === ent.id;
      const anyEngaged = !!you?.engagedEnemyId;

      const combat = ctx.room.combats?.[ent.id] || null;
      const turn = combat?.turn || { phase:"player", turnPid: ctx.playerId, busyUntil:0 };
      const isYourTurn = youEngagedThis && (turn.phase === "player") && (turn.turnPid === ctx.playerId);

      const orbit = ent.state.orbit;
      const full = Object.keys(orbit.assignments||{}).length >= orbit.slots;

      const acts = [
        { label:"Engage", style:"primary", enabled: !anyEngaged && !youEngagedThis && !full, hint: full?"Crowded":(anyEngaged?"Disengage first":""), intent:{ action:Schema.Action.ENGAGE, targetId: ent.id } },
        { label:"Disengage", style:"", enabled: youEngagedThis, hint: youEngagedThis?"":"Not engaged", intent:{ action:Schema.Action.DISENGAGE } }
      ];

      if (youEngagedThis){
        const hint = isYourTurn ? "" : "Enemy is acting…";
        acts.push(
          { label:"Attack", style:"primary", enabled:isYourTurn, hint, intent:{ action:Schema.Action.QUEUE_ACTION, payload:{ type:"attack", targetId: ent.id } } },
          { label:"Defend", style:"", enabled:isYourTurn, hint, intent:{ action:Schema.Action.QUEUE_ACTION, payload:{ type:"defend" } } },
          { label:"Power Strike", style:"", enabled:isYourTurn, hint, intent:{ action:Schema.Action.QUEUE_ACTION, payload:{ type:"skill", targetId: ent.id } } }
        );
      }
      return acts;
    }
  },

  [Schema.EntityKind.OBJECT]: {
    inspect(ent){
      if (ent.state.objectType==="chest"){
        return {
          title: ent.name,
          kindLabel:"Chest",
          sections:[
            { type:"kv", rows:[["Locked", ent.state.locked?"Yes":"No"],["Opened", ent.state.opened?"Yes":"No"]] },
            { type:"text", text: ent.state.opened ? "Opened." : "Might contain loot." }
          ]
        };
      }
      return { title: ent.name, kindLabel:"Object", sections:[{ type:"text", text:"An object." }] };
    },
    actions(ent, ctx){
      const inCombat = !!ctx.you?.engagedEnemyId;
      if (ent.state.objectType==="chest"){
        return [
          { label:"Unlock", style:"", enabled: !inCombat && ent.state.locked, hint: inCombat?"In combat":(ent.state.locked?"Requires Rusty Key":"Not locked"), intent:{ action:Schema.Action.UNLOCK, targetId: ent.id } },
          { label:"Open", style:"primary", enabled: !inCombat && !ent.state.locked && !ent.state.opened, hint: inCombat?"In combat":(ent.state.opened?"Already opened":(ent.state.locked?"Locked":"")), intent:{ action:Schema.Action.OPEN, targetId: ent.id } }
        ];
      }
      return [];
    }
  },

  [Schema.EntityKind.LOOT]: {
    inspect(ent){
      return { title: ent.name, kindLabel:"Loot", sections:[{ type:"kv", rows:[["Rarity", ent.state.rarity]] }, { type:"text", text:"Dropped item." }] };
    },
    actions(ent, ctx){
      const inCombat = !!ctx.you?.engagedEnemyId;
      return [{ label:"Pick Up", style:"primary", enabled: !inCombat, hint: inCombat?"Finish combat first":"", intent:{ action:Schema.Action.PICKUP, targetId: ent.id } }];
    }
  }
};

/* ---------------- Mini-map layout (static, deterministic) ---------------- */
const MapLayout = Object.freeze({
  nodes: {
    room_1: { x:0, y:0, label:"Road" },
    room_2: { x:0, y:-1, label:"Cata" },
    room_3: { x:1, y:0, label:"Forest" },
    room_4: { x:0, y:1, label:"Village" },
  },
  edges: [
    { a:"room_1", b:"room_2" },
    { a:"room_1", b:"room_3" },
    { a:"room_1", b:"room_4" },
    { a:"room_4", b:"room_3" },
  ]
});

function renderMiniMapSVG(currentRoomId){
  const nodes = MapLayout.nodes;
  const edges = MapLayout.edges;

  const xs = Object.values(nodes).map(n=>n.x);
  const ys = Object.values(nodes).map(n=>n.y);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);

  const pad = 22;
  const cell = 56;
  const w = (maxX - minX + 1) * cell + pad*2;
  const h = (maxY - minY + 1) * cell + pad*2;

  const toPx = (x,y) => ({ px: pad + (x - minX) * cell, py: pad + (y - minY) * cell });

  const stroke = "rgba(255,255,255,.22)";
  const roomStroke = "rgba(255,255,255,.18)";
  const roomFill = "rgba(0,0,0,.20)";
  const activeStroke = "rgba(122,168,255,.70)";
  const activeFill = "rgba(122,168,255,.14)";

  let svg = `<svg viewBox="0 0 ${w} ${h}" xmlns="http://www.w3.org/2000/svg">`;
  svg += `<defs>
    <pattern id="grid" width="${cell}" height="${cell}" patternUnits="userSpaceOnUse">
      <path d="M ${cell} 0 L 0 0 0 ${cell}" fill="none" stroke="rgba(255,255,255,.05)" stroke-width="1"/>
    </pattern>
    <filter id="glow" x="-30%" y="-30%" width="160%" height="160%">
      <feGaussianBlur stdDeviation="3" result="blur"/>
      <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
    </filter>
  </defs>`;
  svg += `<rect x="0" y="0" width="${w}" height="${h}" fill="url(#grid)"/>`;

  for (const e of edges){
    const A = nodes[e.a], B = nodes[e.b];
    if (!A || !B) continue;
    const ap = toPx(A.x, A.y), bp = toPx(B.x, B.y);
    svg += `<path d="M ${ap.px} ${ap.py} L ${bp.px} ${bp.py}" stroke="${stroke}" stroke-width="3" stroke-linecap="round"/>`;
  }

  for (const [id, n] of Object.entries(nodes)){
    const p = toPx(n.x, n.y);
    const isActive = id === currentRoomId;
    const r = 14;
    svg += `<g ${isActive ? `filter="url(#glow)"` : ""}>`;
    svg += `<circle cx="${p.px}" cy="${p.py}" r="${r}" fill="${isActive ? activeFill : roomFill}" stroke="${isActive ? activeStroke : roomStroke}" stroke-width="3"/>`;
    svg += `</g>`;
    svg += `<text x="${p.px + 18}" y="${p.py + 5}" fill="rgba(255,255,255,.78)" font-size="13" font-family="ui-sans-serif, system-ui">${escapeHtml(n.label)}</text>`;
  }

  svg += `</svg>`;
  return svg;
}

/* ---------------- App ---------------- */
class App {
  constructor(){
    this.playerId = "p_" + U.uid();
    this.playerName = "You-" + this.playerId.slice(-4);

    this.engine = new GameEngine("world_demo");
    this.transport = new LocalTransport(this.engine);
    this.store = new Store(this.transport, this.playerId);

    this.selectedEntityId = null;

    // defaults: directions + enemies open; loot open because it's important to see drops quickly
    this.groupOpen = { directions:true, players:false, enemies:true, objects:true, loot:true };

    // loot focus plumbing
    this._lastConsumedEventIndex = 0;
    this._pendingFocusEntityId = null;

    this.engine.connect(this.playerId, this.playerName);

    this._wire();
    this.store.subscribe(()=>this.render());
    this.render();
  }

  get ctx(){
    const st = this.store.state;
    if (!st) return null;
    const you = st.players[this.playerId];
    const room = st.rooms[you?.roomId || "room_1"];
    return { playerId:this.playerId, players:st.players, rooms:st.rooms, you, room };
  }

  _wire(){
    const input = document.getElementById("chatInput");
    document.getElementById("sendChat").onclick = ()=>this.sendChat();
    input.addEventListener("keydown",(e)=>{ if(e.key==="Enter") this.sendChat(); });
  }

  sendChat(){
    const input = document.getElementById("chatInput");
    const text = input.value.trim();
    if (!text) return;
    input.value = "";
    this.store.dispatch(Schema.Action.CHAT, null, { text });
  }

  consumeFocusEvents(){
    const events = this.store.events;
    if (!events || !events.length) return;

    for (let i = this._lastConsumedEventIndex; i < events.length; i++){
      const e = events[i];
      const fid = e?.payload?.focusEntityId;
      if (fid) this._pendingFocusEntityId = fid;
    }
    this._lastConsumedEventIndex = events.length;

    if (this._pendingFocusEntityId){
      const ctx = this.ctx;
      const fid = this._pendingFocusEntityId;
      if (ctx?.room?.entities?.[fid]){
        this._pendingFocusEntityId = null;
        this.focusEntity(fid, { openLoot:true, scrollLoot:true });
      }
    }
  }

  _doorProxyIdForExitId(exitId){ return `doorProxy_${exitId}`; }

  _getDoorProxyFromId(id, ctx=this.ctx){
    if (!id || !String(id).startsWith("doorProxy_")) return null;
    const room = ctx?.room;
    if (!room) return null;
    const exitId = String(id).slice("doorProxy_".length);
    const ex = room.entities[exitId];
    if (!ex || ex.kind !== Schema.EntityKind.EXIT) return null;
    const gate = ex.state?.gate || { type:"open" };
    if (gate.type !== "door" || !gate.doorId) return null;
    const door = room.doors?.[gate.doorId] || null;
    return {
      id,
      kind: Schema.EntityKind.OBJECT,
      name: `Door (${titleCase(ex.state.dir)})`,
      _proxyType: "door",
      state: {
        objectType: "door",
        dir: ex.state.dir,
        exitId: ex.id,
        doorId: gate.doorId,
        doorExists: !!door,
        locked: !!door?.locked,
        open: !!door?.open,
        destination: ex.state.toRoomName || ex.state.toRoomId || "Unknown"
      }
    };
  }

  _getDoorProxyFromExit(ex, ctx=this.ctx){
    if (!ex || ex.kind !== Schema.EntityKind.EXIT) return null;
    const gate = ex.state?.gate || { type:"open" };
    if (gate.type !== "door" || !gate.doorId) return null;
    return this._getDoorProxyFromId(this._doorProxyIdForExitId(ex.id), ctx);
  }

  _getSelectableEntity(entityId, ctx=this.ctx){
    const room = ctx?.room;
    if (!room) return null;
    return room.entities[entityId] || this._getDoorProxyFromId(entityId, ctx);
  }

  focusEntity(entityId, opts={openLoot:false, scrollLoot:false}){
    const ctx = this.ctx;
    if (!ctx) return;

    const ent = this._getSelectableEntity(entityId, ctx);
    if (!ent){
      this._pendingFocusEntityId = entityId;
      return;
    }

    this.selectedEntityId = entityId;

    if (opts.openLoot && ent.kind === Schema.EntityKind.LOOT) this.groupOpen.loot = true;
    if (ent?._proxyType === "door") this.groupOpen.objects = true;

    const label = ent.kind === Schema.EntityKind.EXIT
      ? `${titleCase(ent.state.dir)} (${ent.state.toRoomName || ent.state.toRoomId})`
      : ent.name;

    document.getElementById("selectedName").textContent = label;

    this.renderGroups();
    this.renderInspector();

    requestAnimationFrame(()=>{
      if (opts.scrollLoot && ent.kind === Schema.EntityKind.LOOT){
        const lootGroup = document.getElementById("group_loot");
        if (lootGroup) lootGroup.scrollIntoView({ block:"start" });
      }
      const row = document.querySelector(`[data-entity-id="${CSS.escape(entityId)}"]`);
      if (row) row.scrollIntoView({ block:"nearest" });
    });
  }

  renderMiniMap(){
    const ctx = this.ctx;
    if (!ctx) return;
    document.getElementById("minimap").innerHTML = renderMiniMapSVG(ctx.room.id);
  }

  render(){
    const ctx = this.ctx;
    if (!ctx) return;

    document.getElementById("youPill").textContent = ctx.you?.name || "—";
    document.getElementById("roomTitle").textContent = ctx.room.name;
    document.getElementById("roomFlavor").textContent = ctx.room.flavor;

    this.renderRoomPanel();
    this.renderGroups();
    this.renderInspector();
    this.renderStreams();
    this.consumeFocusEvents();
    this.renderMiniMap();
  }

  renderGroups(){
    const ctx = this.ctx;
    const root = document.getElementById("entityGroups");
    root.innerHTML = "";

    this.renderCompass(root, ctx);

    const entities = Object.values(ctx.room.entities);
    const doorObjects = Object.values(ctx.room.entities)
      .filter(e => e.kind===Schema.EntityKind.EXIT)
      .map(ex => this._getDoorProxyFromExit(ex, ctx))
      .filter(Boolean);

    const groups = [
      { key:"players", label:"Players", kinds:[Schema.EntityKind.PLAYER] },
      { key:"enemies", label:"Enemies", kinds:[Schema.EntityKind.ENEMY] },
      { key:"objects", label:"Objects", kinds:[Schema.EntityKind.OBJECT] },
      { key:"loot", label:"Loot", kinds:[Schema.EntityKind.LOOT] },
    ];

    for (const g of groups){
      const baseItems = entities.filter(e => g.kinds.includes(e.kind));
      if (g.key === "objects") baseItems.push(...doorObjects);

      const items = baseItems.sort((a,b) => {
        if (g.key === "loot"){
          const ta = a.state?.createdAt ?? 0;
          const tb = b.state?.createdAt ?? 0;
          if (tb !== ta) return tb - ta;
          return a.name.localeCompare(b.name);
        }
        if (g.key === "objects"){
          const ad = a._proxyType === "door" ? 0 : 1;
          const bd = b._proxyType === "door" ? 0 : 1;
          if (ad !== bd) return ad - bd;
        }
        return a.name.localeCompare(b.name);
      });

      const d = document.createElement("details");
      d.className = "group";
      d.id = "group_" + g.key;
      d.open = !!this.groupOpen[g.key];
      d.addEventListener("toggle", ()=>{ this.groupOpen[g.key] = d.open; });

      const s = document.createElement("summary");
      s.innerHTML = `<span>${escapeHtml(g.label)}</span><span class="countPill">${items.length}</span>`;
      d.appendChild(s);

      const list = document.createElement("div");
      list.className = "elist";

      if (!items.length){
        const empty = document.createElement("div");
        empty.className="muted"; empty.style.fontSize="12px"; empty.textContent="(none)";
        list.appendChild(empty);
      } else {
        for (const ent of items){
          const row = document.createElement("div");
          row.className = "entity";
          row.setAttribute("data-entity-id", ent.id);
          if (ent.id === this.selectedEntityId) row.classList.add("selected");

          const left = document.createElement("div");
          left.className = "row";
          left.style.minWidth = "0";

          const dot = document.createElement("div");
          dot.className = "dot";
          if (ent.kind===Schema.EntityKind.PLAYER){ dot.style.borderColor="rgba(122,168,255,.55)"; dot.style.background="rgba(122,168,255,.20)"; }
          if (ent.kind===Schema.EntityKind.ENEMY){ dot.style.borderColor="rgba(255,90,106,.55)"; dot.style.background="rgba(255,90,106,.18)"; }
          if (ent.kind===Schema.EntityKind.OBJECT){ dot.style.borderColor="rgba(255,204,102,.40)"; dot.style.background="rgba(255,204,102,.10)"; }
          if (ent.kind===Schema.EntityKind.LOOT){ dot.style.borderColor="rgba(61,220,151,.50)"; dot.style.background="rgba(61,220,151,.12)"; }

          const name = document.createElement("div");
          name.className = "name";
          name.textContent = ent.name;

          left.appendChild(dot);
          left.appendChild(name);

          const tag = document.createElement("div");
          tag.className = "tag";
          tag.textContent = ent._proxyType === "door" ? "door" : ent.kind;

          row.appendChild(left);
          row.appendChild(tag);

          row.onclick = ()=> this.focusEntity(ent.id);

          list.appendChild(row);
        }
      }

      d.appendChild(list);
      root.appendChild(d);
    }
  }

  renderCompass(root, ctx){
    const exits = Object.values(ctx.room.entities).filter(e => e.kind === Schema.EntityKind.EXIT);
    const exitsByDir = {};
    for (const ex of exits){
      exitsByDir[ex.state?.dir] = ex;
    }

    const wrap = document.createElement("div");
    wrap.className = "compassWrap";

    const title = document.createElement("div");
    title.className = "compassTitle";
    title.textContent = "Directions";
    wrap.appendChild(title);

    const grid = document.createElement("div");
    grid.className = "compassGrid";

    const makeBtn = (dir, label, cellClass) => {
      const ex = exitsByDir[dir] || null;
      const btn = document.createElement("button");
      btn.className = `compassBtn ${cellClass}`;
      btn.type = "button";
      btn.textContent = label;
      btn.disabled = !ex;
      if (ex){
        btn.title = ex.state.toRoomName || ex.state.toRoomId || titleCase(dir);
        btn.addEventListener("click", ()=>{
          const gate = ex.state?.gate || { type:"open" };
          if (gate.type === "door"){
            const door = ctx.room.doors?.[gate.doorId] || null;
            const blocked = !door || door.locked || !door.open;
            if (blocked){
              const doorProxy = this._getDoorProxyFromExit(ex, ctx);
              if (doorProxy) this.focusEntity(doorProxy.id);
              return;
            }
          }
          this.store.dispatch(Schema.Action.TRAVEL, ex.id, null);
        });
      } else {
        btn.title = "No exit";
      }
      return btn;
    };

    grid.appendChild(makeBtn("north", "North", "cellNorth"));
    grid.appendChild(makeBtn("west", "West", "cellWest"));

    const center = document.createElement("div");
    center.className = "compassCenter cellCenter";
    center.textContent = "You";
    grid.appendChild(center);

    grid.appendChild(makeBtn("east", "East", "cellEast"));
    grid.appendChild(makeBtn("south", "South", "cellSouth"));

    wrap.appendChild(grid);
    root.appendChild(wrap);
  }

  renderRoomPanel(){
    const ctx = this.ctx;
    if (!ctx) return;

    const you = ctx.you || {};
    const xp = you.xp ?? 0;
    const xpNext = you.xpNext ?? 200;
    const lvl = you.lvl ?? 1;
    document.getElementById("statusStrip").textContent = `HP ${U.fmtHp(you.hp ?? 0, you.hpMax ?? 0)} | LVL ${lvl} | XP ${xp}/${xpNext}`;
    document.getElementById("roomTitle").textContent = ctx.room.name;
    document.getElementById("roomFlavor").textContent = ctx.room.flavor;

    const feedEl = document.getElementById("roomFeed");
    const events = this.store.events.slice(-1200);
    const roomId = ctx.room.id;
    const roomEvents = events.filter(e => {
      if (e.kind !== Schema.EventKind.SYSTEM && e.kind !== Schema.EventKind.COMBAT) return false;
      const aud = e.audience || "both";
      if (aud !== "room" && aud !== "both") return false;
      return e.payload?.roomId === roomId;
    }).slice(-200);

    const wasAtBottom = (feedEl.scrollTop + feedEl.clientHeight) >= (feedEl.scrollHeight - 8);
    const fmtTime = (ms) => {
      const d = new Date(ms);
      return `${String(d.getHours()).padStart(2,"0")}:${String(d.getMinutes()).padStart(2,"0")}`;
    };
    const classify = (e) => {
      const t = (e.text || "").toLowerCase();
      if (e.kind === Schema.EventKind.COMBAT) return "rf-combat";
      if (t.includes("loot") || t.includes("picked up") || t.includes("opened chest") || t.includes("unlocked")) return "rf-loot";
      if (t.startsWith("moved ") || t.includes("door is locked") || t.includes("door is closed") || t.includes("opened the") || t.includes("closed the")) return "rf-move";
      return "rf-system";
    };

    feedEl.innerHTML = roomEvents.map(e => {
      const time = fmtTime(e.ts);
      return `<div class="rfMsg ${classify(e)}"><div class="rfTime">${escapeHtml(time)}</div><div class="rfText">${escapeHtml(e.text)}</div></div>`;
    }).join("") || `<div class="muted" style="font-size:12px">No room events yet.</div>`;

    if (wasAtBottom) feedEl.scrollTop = feedEl.scrollHeight;
  }

  renderInspector(){
    const ctx = this.ctx;
    const box = document.getElementById("inspector");

    if (!this.selectedEntityId){
      document.getElementById("selKindPill").textContent="—";
      box.innerHTML = `<div class="muted">Select an entity to see details and actions.</div>`;
      document.getElementById("selectedName").textContent = "None";
      return;
    }

    const ent = this._getSelectableEntity(this.selectedEntityId, ctx);
    if (!ent){
      document.getElementById("selKindPill").textContent="—";
      box.innerHTML = `<div class="muted">That entity no longer exists.</div>`;
      return;
    }

    const handler = Handlers[ent.kind];
    document.getElementById("selKindPill").textContent = ent._proxyType === "door" ? "door" : ent.kind;

    let vm = handler ? handler.inspect(ent, ctx) : null;
    let actions = handler ? handler.actions(ent, ctx) : [];

    if (ent?._proxyType === "door"){
      const inCombat = !!ctx.you?.engagedEnemyId;
      const open = !!ent.state.open;
      const locked = !!ent.state.locked;
      const exists = !!ent.state.doorExists;

      vm = {
        title: ent.name,
        kindLabel: "Door",
        sections:[
          { type:"kv", rows:[
            ["Direction", titleCase(ent.state.dir)],
            ["Destination", ent.state.destination],
            ["Locked", exists ? (locked ? "Yes" : "No") : "Missing"],
            ["Open", exists ? (open ? "Yes" : "No") : "Missing"]
          ]},
          { type:"text", text:"Unlock, then open to pass through this direction." }
        ]
      };

      actions = [
        { label:"Unlock", style:"", enabled: !inCombat && exists && locked, hint: inCombat?"In combat":(exists ? (locked?"Requires Rusty Key":"Not locked") : "Door missing"), intent:{ action:Schema.Action.UNLOCK_DOOR, targetId: ent.state.exitId } },
        { label:"Open", style:"", enabled: !inCombat && exists && !locked && !open, hint: inCombat?"In combat":(exists ? (locked?"Locked":(open?"Already open":"")) : "Door missing"), intent:{ action:Schema.Action.OPEN_DOOR, targetId: ent.state.exitId } },
        { label:"Close", style:"", enabled: !inCombat && exists && open, hint: inCombat?"In combat":(exists ? (open?"":"Already closed") : "Door missing"), intent:{ action:Schema.Action.CLOSE_DOOR, targetId: ent.state.exitId } }
      ];
    }

    const sections = vm?.sections || [];
    const hpSec = sections.find(sec => sec.type === "hp");
    const kvSecs = sections.filter(sec => sec.type === "kv");
    const textSecs = sections.filter(sec => sec.type === "text");

    const parts=[];
    parts.push(`<div class="card">`);
    parts.push(`<div class="h1">${escapeHtml(vm?.title ?? ent.name)}</div>`);
    parts.push(`<div class="tiny">${escapeHtml(vm?.kindLabel ?? ent.kind)}</div>`);

    if (hpSec){
      const pct = hpSec.hpMax ? Math.round((hpSec.hp/hpSec.hpMax)*100) : 0;
      parts.push(`<div style="display:flex; justify-content:space-between; font-size:12px; color:var(--muted)"><span>HP</span><span>${escapeHtml(U.fmtHp(hpSec.hp, hpSec.hpMax))}</span></div>`);
      parts.push(`<div class="bar bad"><div style="width:${pct}%;"></div></div>`);
    }

    parts.push(`<div style="font-weight:1000">Actions</div>`);
    parts.push(`<div class="actions">`);
    if (!actions.length){
      parts.push(`<span class="muted" style="font-size:12px">No actions available.</span>`);
    } else {
      for (let i=0;i<actions.length;i++){
        const a = actions[i];
        const cls=["btn","small"];
        if (a.style==="primary") cls.push("primary");
        const disabled = a.enabled ? "" : "disabled";
        const title = a.enabled ? "" : (a.hint||"Unavailable");
        parts.push(`<button class="${cls.join(" ")}" data-act="${i}" ${disabled} title="${escapeAttr(title)}">${escapeHtml(a.label)}</button>`);
      }
    }
    parts.push(`</div>`);

    parts.push(`<details class="inspectorDetails"><summary>Details</summary>`);
    for (const sec of kvSecs){
      parts.push(`<div class="kv">` + sec.rows.map(([k,v])=>`<div>${escapeHtml(k)}</div><div>${escapeHtml(v)}</div>`).join("") + `</div>`);
    }
    for (const sec of textSecs){
      parts.push(`<div class="hint">${escapeHtml(sec.text)}</div>`);
    }
    parts.push(`</details>`);
    parts.push(`</div>`);

    box.innerHTML = parts.join("");

    box.querySelectorAll("button[data-act]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const idx = Number(btn.getAttribute("data-act"));
        const a = actions[idx];
        if (!a || !a.enabled) return;
        const intent = a.intent || {};
        this.store.dispatch(intent.action, intent.targetId || ent.id || null, intent.payload || null);
      });
    });
  }

  renderStreams(){
    const logEl = document.getElementById("logStream");
    const chatEl = document.getElementById("chatStream");
    const events = this.store.events.slice(-800);

    const chats = events.filter(e => e.kind === Schema.EventKind.CHAT);

    const logs = events.filter(e => {
      if (e.kind !== Schema.EventKind.SYSTEM && e.kind !== Schema.EventKind.COMBAT) return false;
      const aud = e.audience || "both";
      if (aud !== "personal" && aud !== "both") return false;
      const a = e.payload?.actorPlayerId;
      const t = e.payload?.targetPlayerId;
      return (a === this.playerId) || (t === this.playerId);
    });

    const logWasAtBottom = (logEl.scrollTop + logEl.clientHeight) >= (logEl.scrollHeight - 8);
    const chatWasAtBottom = (chatEl.scrollTop + chatEl.clientHeight) >= (chatEl.scrollHeight - 8);

    const fmtTime = (ms) => {
      const d = new Date(ms);
      const hh = String(d.getHours()).padStart(2,"0");
      const mm = String(d.getMinutes()).padStart(2,"0");
      return `${hh}:${mm}`;
    };

    logEl.innerHTML = logs.map(e => {
      const time = fmtTime(e.ts);
      const who = e.payload?.actorPlayerId===this.playerId ? "You" : "Them";
      return `<div class="msg">
        <div class="time">${escapeHtml(time)}</div>
        <div class="who">${escapeHtml(who)}</div>
        <div class="text">${escapeHtml(e.text)}</div>
      </div>`;
    }).join("");

    chatEl.innerHTML = chats.map(e => {
      const time = fmtTime(e.ts);
      let who = "Chat";
      let text = e.text || "";
      const m = text.match(/^([^:]{1,40}):\s*(.*)$/);
      if (m){ who = m[1].trim(); text = m[2]; }
      return `<div class="msg">
        <div class="time">${escapeHtml(time)}</div>
        <div class="who">${escapeHtml(who)}</div>
        <div class="text">${escapeHtml(text)}</div>
      </div>`;
    }).join("");

    if (logWasAtBottom) logEl.scrollTop = logEl.scrollHeight;
    if (chatWasAtBottom) chatEl.scrollTop = chatEl.scrollHeight;
  }
}

window.app = new App();
</script>
</body>
</html>
